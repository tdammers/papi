<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
<h1 id="papi">papi</h1>
<h2 id="low-boilerplate-restful-apis">Low-Boilerplate RESTful APIs</h2>
<h2 id="introduction">Introduction</h2>
<p>papi is a library that allows you to build powerful <a href="https://en.wikipedia.org/wiki/Restful">RESTful</a> web services on top of plain WSGI by writing backends as simple and semantic classes, and then feeding them to its equally simple WSGI wrapper function.</p>
<h2 id="features">Features</h2>
<ul>
<li>Proper RESTful semantics over HTTP(S): GET, PUT, POST, DELETE map to retrieve / list resources, create, update, delete</li>
<li>Automatic routing</li>
<li>Automatic <a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a> decoration (adds links to parent, self, and children, on every JSON response)</li>
<li>Semi-automatic content type negotiation: JSON is handled transparently, other content types are easy to support in your backend code</li>
<li>Automatic translations of failures to HTTP error responses; uses the 4xx range of status codes correctly</li>
<li>Runs on any compliant WSGI host, making it suitable for deployment under a wide range of web servers and protocols</li>
<li>Method override: fake unsupported HTTP methods through GET parameters or headers</li>
</ul>
<h2 id="installing">Installing</h2>
<p>Installing with pip:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install papi</code></pre>
<p>You probably want to do this in a virtualenv.</p>
<h2 id="conceptual-model">Conceptual Model</h2>
<p>Papi's concept of a RESTful API is that of a tree-shaped data structure, consisting of &quot;leaf&quot; nodes called &quot;documents&quot; and &quot;branch&quot; nodes called &quot;collections&quot;. Both are modelled as <em>resources</em>, and a resource can act as a document, as a collection, or both. Documents have a body (potentially available in multiple flavors, matching different MIME content types); collections have child resources, and the library code maps this resource tree onto a URL path structure. As RESTfulness has it, HTTP methods indicate the kind of operation on this tree, and the HATEOAS philosophy is applied by tagging documents and collections with metadata when possible.</p>
<h2 id="usage">Usage</h2>
<h3 id="defining-a-resource">Defining A Resource</h3>
<p>To implement a working RESTful API, you need to define a root resource. Resources can act as documents (having a body), collections (having child resources), or hybrids (having both a body and child resources). For the root resource, you almost certainly want a collection-style resource, otherwise your API will only ever contain one document.</p>
<p>Note that <code>Resource</code> is not a base class, it's just an implicit interface. Papi resolves method calls through duck typing, there is no need to inherit or formally implement anything, just add the methods you need, and that's it. Adding other methods is of course no problem at all.</p>
<p>The relevant methods for a resource are:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> get_structured_body(<span class="ot">self</span>, digest=<span class="ot">False</span>)
<span class="kw">def</span> get_typed_body(<span class="ot">self</span>, mime_pattern)</code></pre>
<p>Get the payload data for the resource itself; implementing these methods makes the resource a document.</p>
<p><code>get_typed_body</code> is always tried first; it should return a pair of <code>(mime_type, body)</code> to indicate that a body is available that matches the <code>mime_pattern</code>, or <code>None</code> to tell Papi that this MIME type cannot be satisfied.</p>
<p>For some &quot;special&quot; MIME types (currently only <code>text/json</code> and <code>application/json</code>), the <code>get_structured_body</code> method is tried when <code>get_typed_body</code> fails; this method is supposed to return a native Python data structure. Currently, the only requirement is that the returned data must be JSON-encodable, but in the future, other types may be supported (e.g. XML, plain text, HTML, ...), so it's best to stick with &quot;vanilla&quot; data structures that directly correspond to JSON types: <code>dict</code>, <code>list</code>, <code>tuple</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code> and <code>None</code> are all safe to use, others might not. The <code>digest</code> argument indicates whether the full body should be returned, or a &quot;digest&quot; version that contains only the essential properties. <code>digest</code> will be <code>True</code> when called on a child resource in a collection listing context, <code>False</code> when the resource is requested directly.</p>
<p>The crux with these two methods is that <strong>documents derived from <code>get_typed_body</code> are never parsed, and no metadata is ever added</strong>. This means that if you want to have Papi add HATEOAS links and a list of child resources to the response, you must implement <code>get_structured_body</code>, and if you also implement <code>get_typed_body</code>, it must return <code>None</code> for at least the JSON content types (and, in the future, any content type you want to have tagged with metadata).</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> get_children(<span class="ot">self</span>, *args, **kwargs)
<span class="kw">def</span> get_child(<span class="ot">self</span>, name)</code></pre>
<p>These methods need to be implemented for resources that act as collections. <code>get_children</code> returns a list of <code>(name, resource)</code> pairs, and can take the following arguments to alter its behavior:</p>
<ul>
<li><code>offset</code>: the number of items to skip from the beginning of the list. Works like Python's <code>x[offset:]</code> construct, or the <code>OFFSET</code> part in an SQL <code>LIMIT</code> clause.</li>
<li><code>count</code>: the number of items to return, starting at the <code>offset</code> if provided. Works like Python's <code>x[:count]</code> construct, or the <code>COUNT</code> part in an SQL <code>LIMIT</code> clause.</li>
<li><code>page</code>: when <code>count</code> is specified, you can provide a page number instead of an <code>offset</code>. Page numbers are 1-based, and each page contains <code>count</code> entries, so <code>page=2, count=10</code> retrieves items 10 through 19.</li>
</ul>
<p><code>get_child</code> gets a single child resource; the <code>name</code> parameter, throughout Papi's Python API, refers to a resource's primary key. We call it &quot;name&quot;, because ideally, it should be a somewhat descriptive, meaningful natural identifier for the object it represents, which, when possible, is more in line with the RESTful philosophy, and makes for naturally beautiful URIs. <code>http://example.org/api/fruit/apples/granny_smith</code> is a much nicer URI than <code>http://example.org/api/5d75e3/35b0bd/d68c481bb1f4</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> create(<span class="ot">self</span>, <span class="dt">input</span>, content_type=<span class="ot">None</span>)
<span class="kw">def</span> store(<span class="ot">self</span>, <span class="dt">input</span>, name, content_type=<span class="ot">None</span>)
<span class="kw">def</span> delete(<span class="ot">self</span>, name)</code></pre>
<p>These methods can optionally be implemented to turn a readonly resource into a writeable collection. Note that <em>all</em> write operations are defined on the parent resource, even though at the HTTP level, some are exposed on the resource itself - for example, <code>POST /root/child1</code> maps to the resource named <code>&quot;child1&quot;</code> under the parent resource <code>&quot;root&quot;</code>, but the method that gets called is the <code>store</code> method of the <code>root</code> resource. This is for two reasons: one, the child resource to store may not exist yet (this is the case for <code>PUT</code> requests), and two, the resource itself does not know its own name, nor does it need to.</p>
<p>Some notes on these methods:</p>
<ul>
<li>The <code>input</code> argument will contain a file-like object, which means you can use the usual <code>read()</code> etc. methods on it to extract the body. Parsing is your own responsibility, Papi does not do this for you. Particularly, there is no write equivalent to the <code>get_structured_body</code> method; however, processing JSON documents is usually a simple matter of calling <code>json.loads</code>.</li>
<li>The difference between <code>create</code> and <code>store</code> is that <code>create</code> must generate a name for the received document, and return a <code>name, body</code> tuple (where <code>body</code> is a digest that describes the document that has been created, in a JSON-encodable data structure according to the same rules as <code>get_structured_body</code>); multiple calls to <code>create</code> should create multiple distinct documents, and return distinct names. Conceptually, <code>create</code> <em>always</em> creates a new document. By contrast, <code>store</code> takes a document name as an argument, so it does not generate one itself, and multiple calls with the same name will overwrite one another. While <code>store</code> may also create new documents (if the <code>name</code> does not exist yet), it should overwrite (update) documents when the name already exists.</li>
</ul>
<h3 id="serving-a-resource">Serving A Resource</h3>
<p>Serving a resource is simple; the <code>serve_resource</code> function can be used to turn a valid resource into a WSGI application, like this:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> application(env, start_response):
    <span class="kw">return</span> serve_resource(root_resource, env, start_response)</code></pre>
<p>And from there, it's a matter of feeding that function to a WSGI server (see the <a href="https://wsgi.readthedocs.io/en/latest/">WSGI documentation</a> for details).</p>
<h3 id="give-it-a-spin">Give It A Spin</h3>
<p>The included example application (<code>example/app.py</code>) implements a simple in-memory database that supports plain-text payloads for documents; all the resources in it are read/write document/collection hybrids, which means that data can be added at any point in the tree. Assuming that this application runs in a WSGI server on localhost:5000, we can try a few requests (we'll use cURL for these examples):</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/&#39;</span> <span class="co"># Fetch the root resource</span>

{<span class="st">&quot;_parent&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>}, <span class="st">&quot;_self&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>}, <span class="st">&quot;_items&quot;</span>: [{<span class="st">&quot;_parent&quot;</span>:
{<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>}, <span class="st">&quot;_self&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>}, <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;things&quot;</span>}]}</code></pre>
<p>That's not very readable, but we can use the <code>pretty</code> parameter to pretty-print JSON output:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/?pretty=1&#39;</span>
<span class="kw">{</span>
  <span class="st">&quot;_parent&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_self&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_items&quot;</span>:<span class="kw"> [</span>
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;things&quot;</span>
    }
 <span class="kw"> ]</span>
<span class="kw">}</span></code></pre>
<p>This tells us a few things:</p>
<ul>
<li>The URI for this resource (<code>_self</code>) is <code>/</code></li>
<li>The URI for this resource's parent (<code>_parent</code>) is also '/' (this is actually a misfeature currently; the root node should not actually report a parent)</li>
<li>The resource contains child resources (<code>_items</code>)</li>
<li>To be specific, it contains <em>one</em> child resource, named <code>things</code>, with a URI of <code>/things</code>.</li>
</ul>
<p>As you can see, this HATEOAS metadata makes the API fully discoverable; the resource tells us its own location within the API, as well as those of its parent and children.</p>
<p>Let's look at the child resource &quot;things&quot;:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/?pretty=1&#39;</span>
<span class="kw">{</span>
  <span class="st">&quot;_parent&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_self&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_items&quot;</span>:<span class="kw"> [</span>
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/apple&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I am an apple. Eat me.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;apple&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/banana&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I&#39;ll bend either way for you.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;banana&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/nut&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I&#39;m nuts!&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;nut&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/onion&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Hurt me, and I will make you cry.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;onion&quot;</span>
    }
  ],
  <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;things&quot;</span>
}</code></pre>
<p>Oh joy! What a bunch of things! And they're still fully HATEOAS-discoverable, so let's see what happens when we try to fetch an onion:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/onion/?pretty=1&#39;</span>
<span class="kw">Hurt</span> me, and I will make you cry.</code></pre>
<p>That's weird. No JSON. Why is that? Right, content negotiation. Our example resource supports <code>text/plain</code> as well as JSON; curl, by default, specifies that it accepts <code>*/*</code>, that is, <em>anything</em>, and because Papi prefers &quot;typed&quot; bodies over &quot;structured&quot; bodies, the first type that matches (which happens to be <code>text/plain</code>) is what we get. If we were serving, say, images through our API, this would be <em>exactly</em> the desired behavior. We can still request JSON though, we just have to override the <code>Accept</code> header:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/onion/?pretty=1&#39;</span> -H <span class="st">&#39;Accept: text/json&#39;</span>
<span class="kw">{</span>
  <span class="st">&quot;_parent&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_self&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/onion&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Hurt me, and I will make you cry.&quot;</span>,
  <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;onion&quot;</span>
<span class="kw">}</span></code></pre>
<p>All is well!</p>
<p>So far, we have only requested things that existed. Of course requesting something that doesn't exist yields a 404 error; we'll use cURL's <code>-i</code> option to show HTTP headers:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/nope/?pretty=1&#39;</span> -i
<span class="kw">HTTP/1.1</span> 404 Not Found
<span class="kw">Content-type</span>: text/plain<span class="kw">;</span><span class="ot">charset=</span>utf8

<span class="kw">Not</span> Found</code></pre>
<p>That makes sense.</p>
<p>What happens if we request a content type that the resource doesn't support?</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/onion/?pretty=1&#39;</span> -i -H <span class="st">&#39;Accept: img/png&#39;</span>
<span class="kw">HTTP/1.1</span> 406 Not Acceptable
<span class="kw">Content-type</span>: text/plain<span class="kw">;</span><span class="ot">charset=</span>utf8

<span class="kw">Not</span> Acceptable</code></pre>
<p>It does the right thing.</p>
<p>So far we've only been <em>reading</em> from the API; let's try <em>writing</em> things. According to standard RESTful procedures, we can create new documents by using the HTTP <code>PUT</code> method:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato&#39;</span> -XPUT -i -H <span class="st">&#39;Content-Type: text/plain&#39;</span>
<span class="kw">HTTP/1.1</span> 200 OK
<span class="kw">Content-type</span>: application/json

{<span class="st">&quot;_parent&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>}, <span class="st">&quot;_self&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/potato&quot;</span>}, <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Slice me, dice me, fry me&quot;</span>}</code></pre>
<p>The status code <code>200</code> indicates that the document was indeed created, and fetching the <code>_self</code> URI confirms this:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato/?pretty=1&#39;</span>
<span class="kw">Slice</span> me, dice me, fry me</code></pre>
<p>And of course, this new document supports JSON as well:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato/?pretty=1&#39;</span> -H <span class="st">&#39;Accept: text/json&#39;</span>
<span class="kw">{</span>
  <span class="st">&quot;_parent&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_self&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/potato&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Slice me, dice me, fry me&quot;</span>,
  <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;potato&quot;</span>
<span class="kw">}</span></code></pre>
<p>Note that if you want to access the API from a web browser, it will almost certainly not support any HTTP methods other than <code>GET</code> and <code>POST</code> (plus a few that we don't care much about here, such as <code>HEAD</code> and <code>OPTIONS</code>); <code>PUT</code> and <code>DELETE</code>, in particular, will not work. Because of this, Papi has a method override feature: if you add a <code>_method</code> parameter to the query string, or a <code>X-Method-Override</code> header to the request, the value of that will override the actual request method. So the following curl requests would all produce the same behavior:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato&#39;</span> -XPUT -i -H <span class="st">&#39;Content-Type: text/plain&#39;</span>
<span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato?_method=PUT&#39;</span> -XPOST -i -H <span class="st">&#39;Content-Type: text/plain&#39;</span>
<span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato&#39;</span> -XPOST -i -H <span class="st">&#39;X-Method-Override: PUT&#39;</span> -H <span class="st">&#39;Content-Type: text/plain&#39;</span></code></pre>
<p>An alternative way of creating new documents is using the HTTP method <code>POST</code> on the <em>parent</em> resource, leaving the responsibility of generating a suitable unique name for the new document to the parent resource. This is what that looks like:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things?pretty=1&#39;</span> -XPOST -i -H <span class="st">&#39;Content-Type: text/plain&#39;</span> -d<span class="st">&#39;Carrot on a stick&#39;</span>
<span class="kw">HTTP/1.1</span> 200 OK
<span class="kw">Content-type</span>: application/json

{<span class="st">&quot;_parent&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>}, <span class="st">&quot;_self&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/carrot&quot;</span>}, <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Carrot on a stick&quot;</span>}</code></pre>
<p>Our example resource is configured to generate names based on the first word of the input, so that's what we get: <code>&quot;carrot&quot;</code>.</p>
<p>Other than the <code>PUT</code> method, however, <code>POST</code> will always create a new document, rather than overwrite an existing one, so if we <code>POST</code> the same thing again, the API is required to either deny the request with a <code>Conflict</code> response, or create a new document with a different unique name. Our example application opts for the second solution:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things?pretty=1&#39;</span> -XPOST -i -H <span class="st">&#39;Content-Type: text/plain&#39;</span> -d<span class="st">&#39;Carrot on a stick&#39;</span>
<span class="kw">HTTP/1.1</span> 200 OK
<span class="kw">Content-type</span>: application/json

{<span class="st">&quot;_parent&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>}, <span class="st">&quot;_self&quot;</span>: {<span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/BL6yCijd8x4Mwzcf-carrot&quot;</span>}, <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Carrot on a stick&quot;</span>}</code></pre>
<p>As you can see, the name is disambiguated by prepending a random token. Listing the <code>/things</code> resource shows that two documents have actually been created:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things?pretty=1&#39;</span> -H <span class="st">&#39;Accept: text/json&#39;</span>
<span class="kw">{</span>
  <span class="st">&quot;_parent&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_self&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_items&quot;</span>:<span class="kw"> [</span>
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/BL6yCijd8x4Mwzcf-carrot&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Carrot on a stick&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;BL6yCijd8x4Mwzcf-carrot&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/apple&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I am an apple. Eat me.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;apple&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/banana&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I&#39;ll bend either way for you.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;banana&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/carrot&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Carrot on a stick&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;carrot&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/nut&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I&#39;m nuts!&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;nut&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/onion&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Hurt me, and I will make you cry.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;onion&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/potato&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Slice me, dice me, fry me&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;potato&quot;</span>
    }
  ],
  <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;things&quot;</span>
}</code></pre>
<p>And of course our example application also supports deleting items, using the <code>DELETE</code> method:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things/potato/?pretty=1&#39;</span> -i -XDELETE
<span class="kw">HTTP/1.1</span> 204 No Content
<span class="kw">Content-type</span>: text/plain</code></pre>
<p>Note the use of the <code>204 No Content</code> status line; since we've deleted a resource, there is no meaningful content to return, all we get is an empty success response. And to confirm that the potato has indeed been deleted:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">curl</span> <span class="st">&#39;http://localhost:5000/things?pretty=1&#39;</span> -H <span class="st">&#39;Accept: text/json&#39;</span>
<span class="kw">{</span>
  <span class="st">&quot;_parent&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_self&quot;</span>: <span class="kw">{</span>
    <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
  <span class="kw">}</span>,
  <span class="st">&quot;_items&quot;</span>:<span class="kw"> [</span>
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/BL6yCijd8x4Mwzcf-carrot&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Carrot on a stick&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;BL6yCijd8x4Mwzcf-carrot&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/apple&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I am an apple. Eat me.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;apple&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/banana&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I&#39;ll bend either way for you.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;banana&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/carrot&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Carrot on a stick&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;carrot&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/nut&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;I&#39;m nuts!&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;nut&quot;</span>
    },
    {
      <span class="st">&quot;_parent&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things&quot;</span>
      },
      <span class="st">&quot;_self&quot;</span>: {
        <span class="st">&quot;href&quot;</span>: <span class="st">&quot;/things/onion&quot;</span>
      },
      <span class="st">&quot;_value&quot;</span>: <span class="st">&quot;Hurt me, and I will make you cry.&quot;</span>,
      <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;onion&quot;</span>
    }
  ],
  <span class="st">&quot;_name&quot;</span>: <span class="st">&quot;things&quot;</span>
}</code></pre>
    </body>
</html>
